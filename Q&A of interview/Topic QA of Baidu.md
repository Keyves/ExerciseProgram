# 百度精选面试题

## [requireJS原理](http://www.cnblogs.com/hustskyking/p/how-to-achieve-loading-module.html)
1. 通过创建一个script标签加载资源（或使用ajax）
2. 将加载回调函数toString返回的字符串进行正则处理分析其依赖关系并加载
3. 将加载好的文件文本缓存，再解析字符串正则处理（即步骤2）直至全部加载
> 缓存是为了解决循环加载陷入死循环的境地

和 ES6 module 的区别是requireJS加载的时候只能整体载入（运行时加载），而Module可以做到按需载入（编译时加载）
CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用

# AMD和CMD的区别
CMD就近加载（什么时候需要什么加载），仿CommonJS的语法

AMD预先加载

## BFC和IFC
BFC的布局规矩：

```
1、内部box在垂直方向，一个接一个的放置;
2、box的垂直方向由margin决定，属于同一个BFC的两个box间的margin会重叠
3、BFC区域不会与float box重叠（可用于排版）；
4、BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
5、计算BFC的高度时，浮动元素也参与计算
```

哪些元素或属性会触发BFC？

```
1、根元素；
2、float属性不为none；
3、position为absolute或fixed；
4、display为inline-block, flex, 或者inline-flex；
5、overflow不为visible；
```

## TCP和UDP
| 类型    | TCP     | UDP   |
| ----- | ------- | ----- |
| 是否连接  | 面向连接    | 面向非连接 |
| 传输可靠性 | 可靠的     | 不可靠的  |
| 应用场合  | 传输大量的数据 | 少量数据  |
| 速度    | 慢       | 快     |
> UDP不可靠是因为不需要三次握手即可建立连接

### 建立连接：
首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。

### 断开连接：
假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，"告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，"告诉Client端，好了，我这边数据发完了，准备好关闭连接了"。Client端收到FIN报文后，"就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，"就知道可以断开连接了"。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！

* **注意** 在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。
* **问题1** 为什么连接的时候是三次握手，关闭的时候却是四次握手？
  答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
* **问题2** 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？
  答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。

### 应用：
当强调传输性能而不是传输的完整性时，如：音频和多媒体应用，UDP是最好的选择。在数据传输时间很短，以至于此前的连接过程成为整个流量主体的情况下，UDP也是一个好的选择，如：DNS交换。把SNMP建立在UDP上的部分原因是设计者认为当发生网络阻塞时，UDP较低的开销使其有更好的机会去传送管理数据。TCP丰富的功能有时会导致不可预料的性能低下，但是我们相信在不远的将来，TCP可靠的点对点连接将会用于绝大多数的网络应用。

## [完整的http请求](http://www.a.com/web/httprequest.html)

> 从浏览器输入网址到页面渲染过程中发生了什么

### 域名－dns－ip

1. 先读浏览器dns缓存（一般为1000条，时限一分钟）
2. 再查系统dns缓存
3. 再查hosts文件
4. 浏览器发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址）
5. 运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。
6. 如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找到根域的DNS地址，就会向其发起请求（请问www.a.com这个域名的IP地址是多少啊？）
7. 根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址
8. 向com域的IP地址发起了请求（请问www.a.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.a.com这个域名的IP地址，但是我知道a.com这个域的DNS地址，你去找它去
9. 运营商的DNS又向a.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.a.com这个域名的IP地址是多少？），这个时候a.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.a.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.a.com对应的IP地址，该进行一步的动作了。


### 建立TCP连接

拿到域名对应的IP地址之后，User-Agent（一般是指浏览器）会以一个随机端口（1024 < 端口 < 65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求（原始的http请求经过TCP/IP4层模型的层层封包）到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序（本文就以Nginx为例），最终建立了TCP/IP的连接。
为什么HTTP协议要基于TCP来实现？

目前在Internet中所有的传输都是通过TCP/IP进行的，HTTP协议作为TCP/IP模型中应用层的协议也不例外，TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。

### 发起http请求
浏览器发起了http的请求（看第⑫包），使用的http的方法 GET 方法，请求的URL是 / ,协议是HTTP/1.0
* 格式
```text
起始行：如 GET / HTTP/1.0 （请求的方法  请求的URL 请求所使用的协议）
头部信息：User-Agent  Host等成对出现的值
主体
```



### 服务器端响应http请求，浏览器得到html代码

### 浏览器接收html文件并请求资源
浏览器拿到index.html文件后，就开始解析其中的html代码，遇到js/css/image等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上keep-alive特性了，建立一次HTTP连接，可以请求多个资源，下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源

### 渲染结果
## [模版引擎的实现原理](https://segmentfault.com/a/1190000004420078)

## [单页面路由原理](https://segmentfault.com/a/1190000004075348)

以hash做示范，其运行机制如下:

- 储存hash与对应的回调函数,以key,value的形式存入对象cache中
- 设置监听函数onhashchange监听url的hash变化
- 一旦hash变化，则遍历cache对象,将属性key做正则处理,生成对应的正则,再将其拿去和hash做正则匹配,匹配到后执行相应的value/回调函数
- 回调函数中执行渲染ui的代码,进而更新页面

## 编写jquery插件

```
(function( $ ) {
    $.fn.myPlugin = function() {

        // 插件的具体内容放在这里

    };
})( jQuery );
```

## git基本操作

git init 创建本地仓库

git clone 克隆远程仓库

git add 添加到本地缓存

git rm 删除缓存及本地文件

git mv 删除原名缓存并重命名文件

git status 状态

git diff 对比更改

git checkout 检出分支

git branch 查看分支

git stash 暂存 [apply] 读取

git commit 本地提交

git push 提交到远程

git revert 回滚

git reset [—soft|mixed|soft]重置

## 数据库范式和索引

## mongodb和redis

## 浏览器如何渲染一个页面

## 优化浏览器渲染

### 重绘

当改变那些不会影响元素在网页中的位置的元素样式时，譬如background-color(背景色)， border-color(边框色)， visibility(可见性)，浏览器只会用新的样式将元素重绘一次(这就是重绘，或者说重新构造样式)。

### 重排

当改变影响到文本内容或结构，或者元素位置时，重排或者说重新布局就会发生。这些改变通常由以下事件触发：

- DOM操作（元素添加，删除，修改，或者元素顺序的改变）;
- 内容变化，包括表单域内的文本改变;
- CSS属性的计算或改变;
- 添加或删除样式表;
- 更改“类”的属性;
- 浏览器窗口的操作（缩放，滚动）;
- 伪类激活（：悬停）。

## 设计模式

* 单例
* 策略
* 代理
* 迭代器
* 发布－订阅
* 命令
* 组合
* 模板方法
* 享元
* 职责链
* 中介者
* 装饰者
* 状态
* 适配器

## 操作系统调度算法

### FCFS
先来先服务，也可以称为先进先出

### 轮转
以一个周期性间隔产生时钟中断，此时当前正在运行的进程被置于就绪队列，基于FCFS选择下一个就绪进程运行。

### SPN
最短进程优先，下一次选择所需处理时间最短的进程

### SRT
最短剩余时间优先，总是选择预期剩余时间最短的进程

### HRRN
最高响应比优先，R=(w+s)/s，其中R表示响应比，w表示已经等待的时间，s表示期待服务的时间

### 反馈
程序第一次进入系统是放置于RQ0,第一次被强占并返回就绪态时，放入RQ1，以后每次被强占就下降一级。如果进程处于最低等级，则不再降级，反复返回到该队列，直到结束
