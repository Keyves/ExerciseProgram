<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<script>
/*———————————————————————————————————————————— 数组 ————————————————————————————————————————————*/
	var array = [];

	for (var n = 0; n < 10; n++)
		array.push(Math.round(Math.random() * 10));

	console.log(array);

	/***********数组去重************/
	Array.prototype.unique = function () {
		var len = array.length;
		var obj = {};
		var anoArr = [];
		for (var j = 0; j < len; j++) {
			if (!obj[array[j]]) {
				anoArr.push(array[j]);
				obj[array[j]] = array[j];
			}
		}
		console.log("去重：", anoArr);
	};

	/***********数组挪位************/
	Array.prototype.move = function (k) {
		var len = array.length;
		var anoArr = [];
		/*往右边*/
		for (var j = 0; j < len; j++) {
			anoArr[(j + k) % len] = array[j];
		}
		console.log("挪位-右：", anoArr);
		/*往左边*/
		for (var j = 0; j < len; j++) {
			anoArr[j] = array[(j + k) % len];
		}
		console.log("挪位-左：", anoArr);
	};
	/***********快速排序************/
	Array.prototype.qksort = function () {
		var _this = this;

		var len, temp, half;

		len = this.length - 1;				//破坏有序序列，随机交换两个值
		temp = this[0];
		half = Math.floor(len/2);
		this[0] = this[half];
		this[half] = temp;

		function qksort(l, h) {
			var i, j, flag, tmp;
			i = l;
			j = h;
			flag = _this[l];
			while (i < j) {
				for (; i < j; j--) {				//从j的位置开始向前遍历
					if (_this[j] < flag) {			//当出现大于标兵的数值时
						_this[i++] = _this[j];	//先将_this[i]设置为_this[j],再将最低位向后挪一位
						break;						//退出当前循环
					}
				}
				for (; i < j; i++) {				//从i的位置开始向后遍历
					if (_this[i] > flag) {			//当出现小于标兵的数值时
						_this[j--] = _this[i];	//先将_this[j]设置为_this[i],再将最高位向前挪一位
						break;						//退出当前循环
					}
				}
			}
			_this[i] = flag;						//一轮排序后，将最后的i位置数值置为标兵的数值
			if (--j > l) qksort(l, j);
			if (++i < h) qksort(i, h);				//当最低位和最高位还没超出范围时，递归
		}
		qksort(0, len);
	};
// 	function count(a, b) {
// 		return a - b;
// 	}
// 	var st;
// 	var et;

// 	st = +new Date;
// 	array.sort(count);
// 	et = +new Date;
// 	console.log(et - st);


// console.log(array);


// 	st = +new Date;
// 	array.qksort();
// 	et = +new Date;
// 	console.log(et - st);

// console.log(array);


/*———————————————————————————————————————————— 二叉树 ————————————————————————————————————————————*/

	function Tree() {
		this.data = null;
		this.lchild = null;
		this.rchild = null;
		this.parent = null;
	}

	Tree.prototype.insert = function (data) {			//插入，禁止相同值
		 var node, parent, child;

		 if (!this.data)
		 	return this.data = data;

		 node = this;
		 parent = this;
		 while (node) {
		 	if (data == node.data){
		 		return;
		 	} else {
		 		parent = node;
		 		if (data > node.data)
		 			node = node.rchild;
		 		else
		 			node = node.lchild;
		 	}
		 }
		 child = new Tree();
		 child.data = data;
		 if (data > parent.data)
		 	parent.rchild = child;
		 else
		 	parent.lchild = child;
	};
	Tree.prototype.find = function (data) {			//查找
		 var node, parent, child;

		 if (!this.data)
		 	return this.data = data;

		 node = this;
		 parent = this;
		 while (node) {
		 	if (node.data == data){
		 		return "success";
		 	} else {
		 		parent = node;
		 		if (node.data < data)
		 			node = node.rchild;
		 		else
		 			node = node.lchild;
		 	}
		 }
		 return "lose";
	};
	Tree.prototype.layerorder = function (node) {		//层序
		var queue, tempstack, node, rslt, len, i, j;
		
		node = node || this;
		queue = [];
		rslt = [];

		queue.push(node);

		while (queue.length) {
			for (i = 0; i < queue.length; i++) {
				node = queue.shift();								//队列先出性质
				if(node.lchild) queue.push(node.lchild);
				if(node.rchild) queue.push(node.rchild);		//与上一行换位，则变为从右遍历
				rslt.push(node.data);
			}
		}
			
		return rslt;
	};
	Tree.prototype.preorder = function (node) {		//前序
		var rslt = [];
		if (node) {
			rslt.push(node.data);
			rslt = rslt.concat(node.preorder(node.lchild), node.preorder(node.rchild));
		}
		return rslt;
	};
	Tree.prototype.inorder = function (node) {		//中序
		var rslt = [];
		if (node) {
			rslt = rslt.concat(node.inorder(node.lchild));
			rslt.push(node.data);
			rslt = rslt.concat(node.inorder(node.rchild));
		}
		return rslt;
	};
	Tree.prototype.postorder = function (node) {	//后序
		var rslt = [];
		if (node) {
			rslt = rslt.concat(node.postorder(node.lchild), node.postorder(node.rchild));
			rslt.push(node.data);
		}
		return rslt;
	};
	Tree.prototype.max = function (node) {			//最大值
		var parent;

		node = node || this;
		while (node) {
			parent = node;
			node = node.rchild;
		}
		return parent.data;
	};
	Tree.prototype.min = function (node) {			//最小值
		var parent;

		node = node || this;
		while (node) {
			parent = node;
			node = node.lchild;
		}
		return parent.data;
	};
	var tree = new Tree();
	for (var ti = 0, tlen = array.length; ti < tlen; ti++) {
		tree.insert(array[ti]);
	}

	console.log("tree:", tree);
	console.log("tree->find(50):", tree.find(50));
	console.log("tree->layerorder:", tree.layerorder(tree));
	console.log("tree->preorder:", tree.preorder(tree));
	console.log("tree->inorder(sort):", tree.inorder(tree));
	console.log("tree->postorder:", tree.postorder(tree));
	console.log("tree->max:", tree.max());
	console.log("tree->min:", tree.min());

/*———————————————————————————————————————————— 图 ————————————————————————————————————————————*/
	function Graph(vexnum, arcnum) {			//无向图
		this.vexs = [];
		this.arcs = [];
		this.vexnum = vexnum || 0;
		this.arcnum = arcnum || 0;
	}

	Graph.prototype.search = function (vx) {		//查找顶点
        for (var i = 0; i < this.vexnum; i++)
            if (this.vexs[i] === vx)
            	return i;

        return -1;
    };

    Graph.prototype.addvex = function (vx) {		//添加节点
    	var i, j;

    	if (this.search(vx) !== -1)
            return console.log('顶点已经存在!');

        j = this.vexnum;

        this.vexs[this.vexnum++] = vx;

        for (i = 0; i < this.vexnum; i++) {
            this.arcs[i] = this.arcs[i] || [];
            this.arcs[j] = this.arcs[j] || [];
            this.arcs[i][j] = 0;
            this.arcs[j][i] = this.arcs[i][j];
        }
    };

    Graph.prototype.addarc = function (v1, v2) {		//添加弧
    	var i, j;

    	i = this.search(v1);
    	j = this.search(v2);

    	if (i === -1 || j === -1)
            return console.log('不存在顶点!');

        this.arcs[i][j] = 1;
        this.arcs[j][i] = this.arcs[i][j];

    };

	Graph.prototype.BFS = function () {				//广度优先搜索
		var i, j, k, visited, queue, rslt;

		visited = [];
		queue = [];
		rslt = [];

		for (i = 0; i < this.vexnum; i++)
			visited[i] = false;

		for (i = 0; i < this.vexnum; i++) {
			if (!visited[i]) {
			    visited[i] = true;
			    queue.push(i);

				rslt.push(this.vexs[i]);	//test

			    while (queue.length !== 0) {
			        k = queue.shift();

			        for (j = 0; j < this.vexnum; j++) {
			            if (this.arcs[k][j] === 1 && !visited[j]) {
			                visited[j] = true;
			                queue.push(j);

							rslt.push(this.vexs[j]);	//test
			            }
			        }
			    }
			}
		}
		return rslt;
	};

	// Graph.prototype.DFS = function () {			//深度优先搜索（非递归）
	// 	var i, j, k, visited, stack, rslt;

	// 	visited = [];
	// 	stack = [];
	// 	rslt = [];

	// 	for (i = 0; i < this.vexnum; i++)
	// 		visited[i] = false;

	// 	for (i = 0; i < this.vexnum; i++) {
	// 		if (!visited[i]) {
	// 			visited[i] = true;
	// 			stack.push(i);

	// 			rslt.push(this.vexs[i]);

	// 			while (stack.length !== 0) {
	// 				k = stack.pop();

	// 				for (j = 0; j < this.vexnum; j++) {
	// 					if (this.arcs[k][j] === 1 && !visited[j]) {
	// 			                visited[j] = true;
	// 			                stack.push(j);

	// 							rslt.push(this.vexs[j]);	//test
	// 					} else {
	// 						stack.pop();
	// 					}
	// 				}
	// 			}
	// 		}
	// 	}
	// 	return rslt;
	// };

	Graph.prototype.DFS_REC = function () {		//深度优先搜索（递归）
		var i, visited, rslt;

		visited = [];
		rslt = [];

		for (i = 0; i < this.vexnum; i++)
			visited[i] = false;
		for (i = 0; i < this.vexnum; i++)
			if (!visited[i])
				DFS(this, i);

		function DFS(that, i) {
			var j;

			visited[i] = true;

			rslt.push(that.vexs[i]);		//test

			for (j = 0; j < that.vexnum; j++)
				if (that.arcs[i][j] === 1 && !visited[j])
					DFS(that, j);
		}
		return rslt;
	};

	var graph = new Graph(0, 9);

	graph.addvex('A');
	graph.addvex('E');
	graph.addvex('F');
	graph.addvex('G');
	graph.addvex('H');
	graph.addvex('I');
	graph.addvex('B');
	graph.addvex('C');
	graph.addvex('D');

	graph.addarc('A', 'B');
	graph.addarc('A', 'F');
	graph.addarc('B', 'C');
	graph.addarc('B', 'I');
	graph.addarc('B', 'G');
	graph.addarc('F', 'G');
	graph.addarc('F', 'E');
	graph.addarc('C', 'D');
	graph.addarc('C', 'I');
	graph.addarc('D', 'I');
	graph.addarc('D', 'G');
	graph.addarc('D', 'H');
	graph.addarc('D', 'E');
	graph.addarc('E', 'H');
	graph.addarc('G', 'H');

	console.log(graph);

	//console.log("深度优先搜索（非递归）", graph.DFS());
	console.log("深度优先搜索（递归）", graph.DFS_REC());
	console.log("广度优先搜索", graph.BFS());


	</script>
</body>
</html>