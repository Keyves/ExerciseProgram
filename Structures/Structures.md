#Day1

##路线
- 数组
	+ 去重
	+ 挪位
	+ 快速排序
- 树
	+ 插入
	+ 查找
	+ 先序
	+ 中序
	+ 后序
	+ 最大值
	+ 最小值
	+ 层序遍历
- 图
	+ 查找
	+ 添加节点
	+ 添加弧
	+ 广度(层序)
	+ 深度(先序)

##总结

###数组

- 去重：
	运用对象键值对应的方式，若不存在于对象中->将值添加到对象，若存在则跳过

- 挪位：
	通过取余形成循环即可

- 快排：
	首先设置一个标兵，从后反向遍历直到出现比标兵大的数，则置换到标兵位，并从前正向遍历直到出现比标兵小的数，则置换到之前大数的位置，以此循环往复;Q->当数组为有序时，快速排序最慢的情况暂时还没有有效的解决方案，另外，当数组过大时，会出现栈溢出的情况

###树

- 插入：
	根据左小右大的方式插入

- 查找：
	根据左小右大的方式遍历树，中间过程加入判断即可

- 先序遍历：
	先获取值，再递归左右节点

- 中序遍历：
	先递归左节点，到叶节点时，获取该节点的值，由于递归的性质，返回到上一级函数中，即返回上一个节点，获取该节点的值，再进入右节点，循环往复，直到遍历完成

- 后序遍历：
	先递归左节点，到叶节点时，获取该节点的值，返回上一节点并进入右节点获取值，再返回上一节点，获取改点值，循环往复

- 最小值 & 最大值：
	由于树的特性，最左边的叶节点为最小值，最右边的叶节点为最大值

- 层序遍历：
	+ 想不出递归的解决方案，每次循环获取队列中的节点并将节点的值插入结果数组中，然后将各节点的子节点插入到备用队列中，将备用队列赋值给队列再置空（已修改）
	+ 修改后：去除备用队列，直接检测队列是否为空即可

###图


- 查找：
	+ 遍历顶点数组即可

- 添加节点：
	+ 首先检测节点是否存在，并初始化矩阵，无向图为对称矩阵

- 添加弧：
	+ 首先判断两个节点是否存在，若存在便将矩阵中该点置1

- 广度搜索[^book]：
	+ 初始化访问标记队列visited
	+ 将0位置入队列queue,进入循环
	+ 跳转至队列弹出k的对称位所在行遍历，并存在位置数为1且未被访问过的，则将该位置的列数号置入队列queue并标记访问
	+ 以此循环往复

- 深度搜索（递归）[^book]：
	+ 初始化访问标记队列visited
	+ 将0位置传入递归函数
	+ 将传入位置标记为已访问
	+ 存在位置数为1且未被访问过的，则将该位置的列数号传入递归
	+ 以此循环往复

- 深度搜索（非递归）[^web]：
	+ 暂时未解决

[^book]:《大话数据结构》
[^web]:www.html-js.com/article/2423

